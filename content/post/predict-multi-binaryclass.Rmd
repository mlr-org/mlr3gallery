---
title: Multiclass to binary class reduction
author: Florian Pfisterer
date: '2020-04-06'
slug: one-vs-all-classification
categories: []
tags: ['mlr3pipelines', 'multiclass']
packages: ['mlr3', 'mlr3learners', 'mlr3viz', 'mlr3pipelines', 'paradox', 'igraph', 'e1071']
---

This use case shows how to do multiple learners for a single task.
Following tasks are illustrated:

* Build a pipeline that can switch between multiple learners.
* Define the hyperparameter search space for the pipeline.
  - Define transformations for single hyperparameters.
  - Define a hierarchical order of the hyperparameters.
* Run a random search.


## Multiclass Tasks

```{r}
library(mlr3)
library(mlr3misc)
library(mlr3pipelines)
library(mlr3learners)
```

Many tasks encountered in real life applications have multiple target classes.
Those are called multi-class tasks.
For illustration, we choose the simplest one: `iris`.

```{r}
task = tsk("iris")
```

It has three classes `r task$class_names`.

Unfortunately not all learners know how to deal with multiple classes, and insteadcan only perform **binary** classification.
 An example for this is  **logistic regression**.

```{r}
po_lrn_vers = po(id = "lrn_vers", lrn("classif.log_reg", predict_type = "prob"))
po_lrn_virg = po(id = "lrn_virg", lrn("classif.log_reg", predict_type = "prob"))
po_lrn_seto = po(id = "lrn_seto", lrn("classif.log_reg", predict_type = "prob"))
```

(We can see that it does not support multiclass, as it is not listed in the *properties*.)

Fortunately, we can reduce multiclass classification to a series of binary class classification tasks using either the **one-vs-one** or the **one-vs-all** approach (Bishop, Christopher M. (2006). Pattern Recognition and Machine Learning. Springer).


## Building the Pipeline

For this tutorial we choose
Conceptually what we aim to do is the following:
- Reduce our task into one task for each target class. 
  All other classes are "rest". 
- Train a binary predictor on each target.
- Collect the resulting predictions, predict the class for which a classifier predicts the highes *probability*.


First we define a helper function `collapse_target` which recodes our data to "one-vs-rest" for each class level.

```{r}
collapse_target = function(x, level) {
  data.table(factor(ifelse(x == level, level, "other")))
}
```

Then we create a target trafo for each target:
Firstwe will do this for `versicolor`:

```{r}
po_vers = po(id = "vers_trafo", "targettrafosimple", param_vals = list(trafo = function(x) {collapse_target(x, "versicolor")}, new_target_name = "versicolor"))
```

and for all other classes:

```{r}
po_virg = po(id = "virg_trafo", "targettrafosimple", param_vals = list(trafo = function(x) collapse_target(x, "virginica"), new_target_name = "virginica"))
po_seto = po(id = "seto_trafo","targettrafosimple", param_vals = list(trafo = function(x) collapse_target(x, "setosa"), new_target_name = "setosa"))
```

Afterwards we create a `targettrafo` pipeline which contains our learner for eacht task:

```{r}
ppl_vers = ppl("targettrafo", trafo_pipeop = po_vers, graph = po_lrn_vers, id_prefix = "vers_")
ppl_virg = ppl("targettrafo", trafo_pipeop = po_virg, graph = po_lrn_virg, id_prefix = "virg_")
ppl_seto = ppl("targettrafo", trafo_pipeop = po_seto, graph = po_lrn_seto, id_prefix = "seto_")
```

Now we collect the pipelines for all targets in a larger graph, in parallel, using `gunion`.

```{r}
graph = gunion(list(ppl_vers, ppl_virg, ppl_seto))
```

We can plot this:

```{r}
graph$plot()
```

The last part we need is a `PipeOp` that collects all predictions and predicts the class with the highest probability.
As this operation is not often required, no `PipeOp`for this exists in `mlr3pipelines` and we have to create it manually. 
This is a good showcase on how simple it is to write custom `PipeOp's` for `mlr3pipelines`:

Our `PipeOp` is very similar to `PipeOpClassifAvg`, as it takes as input several `PredictionClassif`s and produces a single prediction.

```{r, eval = FALSE}
PipeOpCombineBinaryToMulticlass = R6Class("PipeOpCombineBinaryToMulticlass",
  inherit = PipeOpEnsemble,
  public = list(
    initialize = function(innum = 0, id = "bin2multi", param_vals = list()) {
      super$initialize(innum, id, param_vals = param_vals, prediction_type = "PredictionClassif", packages = "stats")
    }
  ),
  private = list(
    weighted_avg_predictions = function(inputs, weights, row_ids, truth) {

        browser()
        # Do something here
        response = weighted_matrix_sum(map(inputs, "prob"), weights)

      PredictionClassif$new(row_ids = row_ids, truth = truth, response = response, prob = prob)
    }
  )
)
```

now we append our new `PipeOp` to the existing graph and test it:

```{r}
graph = graph %>>% PipeOpCombineBinaryToMulticlass$new(innum =3L)
```


```{r}
graph$train(task)
graph$predict(task)
```

The following code shows how this can be done automatically for 
each task:

```{r}
collapse_fct = function(tgt, other = "other") { 
  function(x) {factor(ifelse(x == tgt, tgt, other))}
}
map(task$class_names, function(tgt) {
  po("targettrafosimple", param_vals = list(
      new_target_name = tgt,
      trafo =  function(x) collapse_fct(tgt
  ))
})
```